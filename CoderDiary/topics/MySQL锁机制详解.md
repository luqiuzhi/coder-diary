# MySQL锁机制详解

1.  **按粒度划分**：全局锁、表级锁、行级锁
2.  **按模式划分**：共享锁（S锁）、排他锁（X锁）、意向锁
3.  **行级锁的算法**：记录锁、间隙锁、临键锁、插入意向锁

## 一、 按粒度划分（Granularity）

锁的粒度指的是锁定的数据范围大小。粒度越小，并发度越高，但管理开销越大；粒度越大，并发度越低，但管理开销小。

### 1. 全局锁（Global Lock）
*   **实现原理**：
    *   通过命令 `FLUSH TABLES WITH READ LOCK` (FTWRL) 实现。
    *   它会**关闭所有打开的表**，并对整个数据库实例加一个**全局读锁**。
    *   加锁之后，整个数据库处于只读状态，任何的数据写入（DML）和表结构变更（DDL）操作都会被阻塞。
*   **应用场景**：
    *   **全库逻辑备份**：这是最主要的场景。为了保证备份数据的一致性（即拿到一个逻辑时间点的一致性视图），需要阻止所有写入。但请注意，在支持事务的引擎（如InnoDB）中，使用 `--single-transaction` 参数通过MVCC来获得一致性视图是更好、更并发的选择，全局锁通常是在引擎不支持事务时才用的方法。

### 2. 表级锁（Table-Level Lock）
表级锁会锁定整张表。MySQL中表级锁最常见的是**表锁**和**元数据锁**。

*   **a. 表锁（Table Lock）**
    *   **实现原理**：
        *   通过命令 `LOCK TABLES table_name READ/WRITE` 显式加锁。
        *   读锁（READ）：阻塞其他会话的写操作，不阻塞读操作。
        *   写锁（WRITE）：阻塞其他会话的读写操作。
        *   MyISAM引擎主要使用表锁，执行查询（SELECT）会自动加读锁，执行更新（UPDATE/INSERT/DELETE）会自动加写锁。
    *   **应用场景**：
        *   主要用于不支持行锁的存储引擎（如MyISAM）。
        *   需要一次性锁定整张表进行批量操作，且业务可以接受长时间并发停滞的情况。**在InnoDB中应尽量避免使用，因为会严重破坏并发性。**

*   **b. 元数据锁（Metadata Lock, MDL）**
    *   **实现原理**：
        *   MySQL 5.5引入，用于解决DDL操作与DML操作的一致性問題。
        *   **自动加锁，无需用户干预**。
        *   对一个表做DML操作（SELECT, INSERT, UPDATE, DELETE）时，会自动加一个**MDL读锁**。
        *   对一个表做DDL操作（ALTER TABLE, DROP TABLE）时，会自动加一个**MDL写锁**。
        *   **读锁之间不互斥**，多个会话可以同时对一张表增删改查。
        *   **写锁之间、读写锁之间互斥**。即一个会话要修改表结构（加写锁）时，需要等待所有正在执行的DML操作（持有读锁）完成并释放读锁后才能进行。反之，一个新的DML操作（需要读锁）也会被DDL操作（持有写锁）阻塞。
    *   **应用场景**：
        *   保证表结构变更的安全性，避免出现“查询过程中表结构突然消失”或“字段被修改导致查询结果异常”等情况。
        *   **注意**：长事务会持有MDL读锁，如果此时有DDL操作，会被阻塞，并且后续所有对该表的DML操作都会被阻塞，极易导致数据库连接爆满。

### 3. 行级锁（Row-Level Lock）
行级锁是**InnoDB引擎实现高并发的基石**。它只锁定需要操作的特定行。

*   **实现原理**：
    *   InnoDB的行锁是通过给**索引项**加锁来实现的。这意味着：
        1.  **只有通过索引条件检索数据，InnoDB才会使用行锁**。否则，InnoDB将退化为表锁（实际上是给所有行加锁，再逐步释放不满足条件的行的锁，但效果类似表锁）。
        2.  即使是不同的行，如果它们的索引键值相同，也可能会发生**锁冲突**（例如唯一索引冲突）。
    *   行锁在需要的时候才加上，但并不是在执行完SQL后立刻就释放，而是要等到**事务结束时才释放**（通过两阶段锁协议实现）。这是为了确保事务的隔离性。
*   **应用场景**：
    *   几乎所有需要高并发写的场景，如电商系统中的库存扣减、账户余额变更等。它最大程度地减少了锁的冲突，允许会话同时修改同一张表中的不同行数据。

---

## 二、 按模式划分（Mode）

### 1. 共享锁（Shared Lock, S锁）
*   **原理**：又称读锁。允许一个事务去读一行数据，阻止其他事务获得相同数据集的排他锁。**多个事务可以同时获得同一数据行的S锁**。
*   **加锁方式**：`SELECT ... LOCK IN SHARE MODE;`
*   **兼容性**：S锁与S锁兼容，与X锁不兼容。

### 2. 排他锁（Exclusive Lock, X锁）
*   **原理**：又称写锁。允许获得排他锁的事务更新或删除数据，阻止其他任何事务获取相同数据集的共享锁或排他锁。
*   **加锁方式**：
    *   自动：`UPDATE`, `DELETE`, `INSERT` 语句会自动为受影响的行加X锁。
    *   手动：`SELECT ... FOR UPDATE;`
*   **兼容性**：X锁与任何其他锁（S锁和X锁）都不兼容。

### 3. 意向锁（Intention Locks）
意向锁是**表级锁**，由InnoDB自动添加。它是为了解决“表锁和行锁共存”时的冲突判断问题而设计的。

*   **原理**：当一个事务需要给某一行加S/X锁之前，它必须**先取得该表对应的意向锁**。
    *   **意向共享锁（IS锁）**：事务打算给某些行加S锁。`SELECT ... LOCK IN SHARE MODE` 会加IS锁。
    *   **意向排他锁（IX锁）**：事务打算给某些行加X锁。`SELECT ... FOR UPDATE`、`UPDATE`、`DELETE`、`INSERT` 会加IX锁。
*   **目的**：**为了快速判断表中是否有被锁定的行**。
    *   如果没有意向锁，当另一个事务想给整个表加表锁时，它需要逐行检查是否有行锁存在，效率极低。
    *   有了意向锁，事务想加表锁（例如读锁）时，只需要检查该表是否有与自己冲突的**意向锁**（例如IX锁与表读锁冲突）即可，无需扫描每一行。

**兼容矩阵**（表级锁层面）：

| 请求锁模式  | X  | IX     | S  | IS     |
|:-------|:---|:-------|:---|:-------|
| **X**  | 冲突 | 冲突     | 冲突 | 冲突     |
| **IX** | 冲突 | **兼容** | 冲突 | **兼容** |
| **S**  | 冲突 | 冲突     | 兼容 | 兼容     |
| **IS** | 冲突 | **兼容** | 兼容 | 兼容     |

> 注意：IX锁和IX锁是兼容的，这表明多个事务可以同时向同一张表的不同行申请X锁，这正是高并发的体现。

---

## 三、 行级锁的算法（实现细节）

InnoDB的行锁有三种具体的实现算法，用于在**可重复读（Repeatable-Read）** 隔离级别下解决幻读问题。

### 1. 记录锁（Record Lock）
*   **原理**：锁定索引中**一条具体的记录**。
*   **场景**：`SELECT * FROM table WHERE id = 10 FOR UPDATE;` 会阻止其他事务插入、更新或删除 `id = 10` 的这一行。

### 2. 间隙锁（Gap Lock）
*   **原理**：锁定索引记录之间的**间隙**（一个开区间），但不锁定记录本身。例如，锁定 `(10, 20)` 这个区间，阻止其他事务向这个区间内插入新的记录（`id=15`）。
*   **场景**：防止其他事务在间隙中插入数据，从而**避免幻读**。
    *   `SELECT * FROM table WHERE id BETWEEN 10 AND 20 FOR UPDATE;`
    *   不仅会锁住id=10和20的记录，还会锁住(10, 20)这个区间，防止插入id=15的记录。

### 3. 临键锁（Next-Key Lock）
*   **原理**：**记录锁 + 间隙锁**的组合。它锁定一个记录本身以及该记录之前的间隙（左开右闭区间）。例如，锁定 `(10, 20]`，它锁定了20这条记录和(10, 20)这个间隙。
*   **场景**：这是InnoDB在**可重复读隔离级别下的默认行锁算法**。它同时解决了脏写和幻读的问题。

### 4. 插入意向锁（Insert Intention Lock）
*   **原理**：一种特殊的**间隙锁**，由 `INSERT` 操作在插入行之前设置。**它的存在是为了提高并发插入的性能**。
*   **场景**：多个事务在**同一个间隙**中插入**不同位置**的记录时，不需要互相等待。例如，间隙(10, 20)内，事务A要插入id=15的记录，事务B要插入id=18的记录。它们会各自获取一个插入意向锁，由于彼此不冲突，可以同时插入，从而提高了并发性。

## 总结与对比

| 锁类型       | 粒度     | 主要应用场景                                     | 实现语句/备注                                      |
| :----------- | :------- | :----------------------------------------------- | :------------------------------------------------- |
| **全局锁**   | 整个数据库 | 全库只读备份（现已较少使用）                     | `FLUSH TABLES WITH READ LOCK;`                     |
| **表锁**     | 整张表   | MyISAM引擎；InnoDB的显式锁表                     | `LOCK TABLES ... READ/WRITE;`                      |
| **元数据锁** | 整张表   | 防止DDL和DML冲突                                 | 自动添加                                           |
| **行锁**     | 单行     | InnoDB高并发读写                                 | 通过索引实现                                       |
| **共享锁(S)** | 行/表    | 允许并发读，阻止写                               | `SELECT ... LOCK IN SHARE MODE;`                   |
| **排他锁(X)** | 行/表    | 阻止其他读写                                     | `SELECT ... FOR UPDATE;` DML语句                   |
| **意向锁**   | 表       | 协调行锁与表锁的关系，提升表锁检查效率           | 自动添加                                           |
| **记录锁**   | 行       | 锁定唯一索引的一条具体记录                       | 行锁的基础                                         |
| **间隙锁**   | 间隙     | 防止幻读，锁定范围但不锁定记录                   | 可重复读隔离级别特有                               |
| **临键锁**   | 行+间隙  | 默认行锁算法，同时解决脏写和幻读                 | 可重复读隔离级别默认算法                           |
| **插入意向锁** | 间隙     | 提高并发插入效率                                 | INSERT操作自动添加                                 |

理解这些锁的原理和场景，对于设计高性能、高并发的数据库应用以及诊断处理锁超时、死锁问题至关重要。在大多数OLTP（在线事务处理）应用中，应优先选择InnoDB引擎并充分利用其行级锁特性。