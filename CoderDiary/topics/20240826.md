# 2024.8.26 Java多线程

## 线程的生命周期

![thread-status.png](thread-status.png){ thumbnail="true" }

- 初始状态：每一个线程在创建出来之后都是初始状态。在Java中，未调用`start()`方法的线程就处于初始状态。
- 就绪状态：线程已经执行了`start()`方法，此时线程还未获取到CPU的时间分片，处于等待执行的状态。一旦线程获取到了CPU资源，会立马变为运行状态开始执行自己的逻辑。
- 运行状态：线程已经获取到CPU时间分片，开始执行线程逻辑。
- 阻塞状态：在Java中线程进入阻塞的唯一情况就是线程已经分配了CPU时间但是获取不到锁的情况。此时线程除了等，别无他法，如同桥下抱柱的尾生。线程获取到锁后会立马进入就绪状态。
- 等待状态：其实线程等待状态更像广义的线程阻塞。在Java中主动将线程“阻塞”就是让线程进入等待状态。并且线程的等待状态往往需要外部干预才能回到运行状态。
- 超时等待状态：类似线程等待状态，但是设定了等待时间，一定时间后自动变为运行状态。
- 终止状态：线程执行完成后变为终止状态。

在操作系统层面，线程的运行往往分为就绪（ready）和运行（running）两个状态，但是在JVM的实现中，将这两个状态合二为一，统称运行（runnable）状态。
这是因为在现代的时分多任务操作系统下，一个CPU时间分片只有10~20ms，线程的状态切换的如此之快，更别提就绪和运行两个状态的转换了。对于JVM来说已经没有监控这两个状态变换的必要了，所以直接将两个状态合二为一。

## CPU缓存模型

在讲JVM内存模型之前，可以先讲讲CPU的内存模型，两者之间有很多共通点。

![CPU-cache.png](CPU-cache.png){ thumbnail="true" }

经常搞机的朋友一定知道，CPU一般都有三级缓存，选购CPU的一个指标就是CPU的三级缓存是否够大（固态硬盘同理）。

CPU的一级缓存离CPU最近，大小也最小，但是速度最快。大概3~4个CPU时钟周期。从图上能看出，一级缓存分为两个部分，一部分是数据缓存，一部分是指令缓存。

CPU的二级缓存速度比一级缓存略慢，容量稍大，访问速度大概10~20个CPU时钟周期。

CPU的三级缓存最慢，但容量最大，访问速度大概40~45个时钟周期。最重要的是，前两级缓存是CPU私有的，而三级缓存是多核CPU共有的缓存。

多核CPU在和主存进行数据交换时，往往会发生以下情况：

1. CPU1从RAM中读取变量A = 1，并将A赋值为2。
2. CPU1将A写入自己的缓存，但未更新到RAM。
3. CPU2同时从RAM中读取变量A = 1，并将A赋值为3。
4. CPU2将A写入自己的缓存，但还未更新到RAM。
5. 两个CPU同时将A提交到RAM，此时A是多少呢？

这就是CPU缓存和主存的缓存不一致性。在上图的Bus总线中，人们为了解决缓存不一致的问题，引入了MESI协议。
该协议不深入讨论。但是我们需要知道的是，在多核CPU中，已经通过引入相关协议来解决缓存不一致的情况。

## 指令重排序

现代CPU为了最大限度发挥计算能力，回对指令进行打乱重排，在保证执行结果不变的情况下，对指令进行重排序。而JVM为了提升性能，有时候也会进行指令重排序。

简单说，就是写的代码不一定会原封不动的按照顺序执行。

> Java中的指令重排序有两次，第一次发生在将字节码编译成机器码的阶段，第二次发生在CPU执行的时候，也会适当对指令进行重排。

## JMM(Java Memory Model)

Java内存模型分为主存和线程本地内存。如果把线程比作一个CPU，主存比作RAM，我们会发现Java的内存模型和CPU的缓存模型十分相似。

![JMM.png](JMM.png){ thumbnail="true" }

在Java的内存模型中，也需要解决主内存和线程本地内存的缓存一致性问题，而这个问题在JVM中有几种解决方案，这也是Java并发编程最核心的知识点。

