# CAS锁和扯不清的模块化

那天同事提到CAS锁（没错就是那个一定要用上并发编程的同事），说实话他提出这个字眼的时候我愣了一下。因为干我们这一行的很少有人会提到这么细节的东西。
而且我也只是粗略的了解Java里有哪些锁和分类，并不很熟悉各类锁的含义。

于是今天~~闲来无事~~专门学习了一下CAS的原理。

在这之前，得先提一下模块化之后的一个变化。

## sun包的弃用
在JDK9之后，引入了模块化，同时将一大批类进行了迁移。其中就包括`sun.misc`包下的`Unsafe`类。
为什么提到`Unsafe`类呢？因为Java中的`CAS`锁的实现离不开`Unsafe`里的相关方法。

在JDK9之后`Unsafe`类迁移到在`jdk.internal.misc`包下，而且经过数个版本的迭代，到了JDK17（我的版本是graalvm-17）已经增加了许多方法。
所以在比较旧的文章里可能针对Unsafe的路径有所不同。

顺便说一句，原来的`sun`包已经移到了`jdk.unsupported`包下，显然是不建议再进行使用了。

## 说回正题
`CAS`的英文全称是`Compare And Swap`，即比较然后交换。
其实名字已经说明了一切，CAS能保证多线程间操作的互斥性就是靠比较然后交换。
而`乐观锁`是`CAS`的一大特点。

### 乐观锁和悲观锁
在讲乐观锁和悲观锁之前，我觉得有必要讲一下什么是锁。因为锁的概念不仅在计算机世界普遍存在，也在我们的日常生活中普遍存在。

事实上，整个计算机世界就是建立在二进制之上的基于现实世界的建模。

***什么是锁呢？***

在现实世界中，门上有锁，车上有锁，有时候就连贞操上，都有一把坚不可破的锁。
现实的锁，锁住了我们的车子，我们的房子，我们的贞操，也锁住了我们的自由。
但能保证我们的财产始终属于我们自己。~~除非锁被撬了~~

计算机中的锁，有时候也很像门上的锁。比如大家常举的例子：上厕所。

如果只有一个人使用厕所，那厕所门上没有锁是没关系的，甚至厕所没有门也是没关系的。但是如果有很多人要上同一个厕所，那没有锁是万万不可的。

第一个上厕所的人，我们暂且称之为小明。

1. 小明进了厕所，没上锁，也没人来，一切OK。
2. 小明进了厕所，没上锁，有人来，但开门和小明对视了一会儿后就退出去了，也OK。
3. 小明进了厕所，没上锁，有人来，也没管马桶上没穿裤子的小明就一屁股坐到了小明的身上，那麻烦就大了。
4. 但如果小明进了厕所，上了锁，有人来，这人只能在外面等着，直到小明自己出来。

上面的例子其实体现了锁的一个特性：**互斥性**。锁都是互斥的，就是我用了你就不能用，起码得等我用完。

而什么是`悲观锁`呢？就是我不放心外面（主要是厕所外面）有没有人来，我每次都把门给锁了，还要反锁，再插上门闩。虽然我自己进出都麻烦点，但是能保证这期间一定没人会来打扰。

而`乐观锁`更像是上面的第2种情况，小明每次进去懒得锁门，但是有人来就让别人自己来看，让别人知男而退。乐观锁的本质，就是世上本无锁，锁自在人心。

所以悲观锁实际上是把锁的控制权掌握在自己的手上，而乐观锁是把锁的主动权交给下一个要使用的人。

- 乐观锁多用于“读多写少“的环境，避免频繁加锁影响性能；
- 悲观锁多用于”写多读少“的环境，避免频繁失败和重试影响性能。
- 

而CAS就是一种乐观锁。不同于大名鼎鼎的`synchronized`，CAS在每次线程执行时都不会主动加锁，也就是整个过程中都是没有锁的状态。

那CAS靠什么来保证互斥性呢？

就是就一开始说的`Compare And Swap`比较并交换。

## CAS原理
在`CAS`中具有以下三个值：
- V：要更新的变量(var)
- E：预期值(expected)
- N：新值(new)
在以下的代码中（来自JDK17），V由对象o和offset计算得出（此处的偏移量还没完全理解），E代表expected，N代表x。
```Java
    @IntrinsicCandidate
    public final native boolean compareAndSetInt(Object o, long offset,
                                                 int expected,
                                                 int x);
```

在CAS中，会将要更新的变量V和当前的预期值（也就是旧值）E进行比较，这一步很像前面的例子里的开门确认：我不锁门，你自己开门看吧。
如果V和E相等，就把V更新为N，否则就退出重试。

而在代码实现中，就有很多更多细节了，暂且不表（主要是太晚了），但是不代表以后不表。