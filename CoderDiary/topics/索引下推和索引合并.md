# 索引下推和索引合并

## 一、索引下推

### 1. 核心概念 {id="1_1"}

**索引下推** 是一种优化技术，其核心思想是：**将 `WHERE` 子句中的过滤条件下推到存储引擎层进行，而不是在服务器层进行**。

在没有索引下推的情况下，数据库的执行流程通常是：
1.  存储引擎根据索引（通常是最左前缀匹配）扫描，返回一批**可能满足条件**的行。
2.  服务器层再对这批数据进行 `WHERE` 子句中剩余条件的过滤。

索引下推优化后，流程变为：
1.  存储引擎根据索引扫描时，**同时利用索引中包含的列**，对 `WHERE` 子句中的其他条件进行过滤。
2.  只将**真正满足所有条件**的行返回给服务器层。

### 2. 详细解释与示例 {id="2_1"}

假设我们有一张 `users` 表，并在 `(age, city)` 上建立了复合索引。

```sql
CREATE TABLE users (
    id INT PRIMARY KEY,
    name VARCHAR(100),
    age INT,
    city VARCHAR(100),
    INDEX idx_age_city (age, city)
);
```

执行以下查询：

```sql
SELECT * FROM users WHERE age > 20 AND city = 'Beijing';
```

*   **没有索引下推：**
    1.  存储引擎使用索引 `idx_age_city`，找到所有 `age > 20` 的记录（比如找到1000条）。
    2.  将这1000条记录对应的主键进行回表操作，读取完整行数据。
    3.  服务器层接收到这1000条完整行数据，再应用 `city = 'Beijing'` 条件进行过滤，最终可能只剩下100条。

*   **有索引下推：**
    1.  存储引擎使用索引 `idx_age_city`，找到所有 `age > 20` 的记录。
    2.  **在索引层面，直接检查这些记录的 `city` 字段（因为 `city` 也在索引中）是否等于 `'Beijing'`**。
    3.  只对同时满足 `age > 20` 和 `city = 'Beijing'` 的记录（比如100条）进行回表操作，读取完整行数据。
    4.  服务器层直接得到100条最终结果。

**优点：**
*   **显著减少回表次数**：这是最大的性能收益。减少了存储引擎和服务器层之间的数据传输量。
*   **降低服务器层CPU开销**：服务器层需要过滤的数据量大大减少。

### 3. 各数据库差异 {id="3_1"}

*   **MySQL：**
    *   **支持情况**：从 **MySQL 5.6** 开始引入，默认开启。主要用于 `InnoDB` 和 `MyISAM` 存储引擎。
    *   **确认方式**：在 `EXPLAIN` 的输出中，如果 `Extra` 列出现 **`Using index condition`**，就表示使用了索引下推。
    *   **适用场景**：适用于范围查询（如 `>`， `<`， `LIKE`）和后缀列过滤。对于上面的例子，`city` 是复合索引的第二列，且 `age` 是范围查询，ICP 效果显著。

*   **PostgreSQL：**
    *   **支持情况**：PostgreSQL 没有完全相同的“索引下推”术语，但其 **位图索引扫描** 机制天然包含了类似且更强大的功能。
    *   **工作原理**：当查询条件涉及多个索引或一个索引的多个部分时，PostgreSQL 可以：
        1.  为每个条件在索引中创建一个位图（Bitmap），其中每一位代表一个数据页或一条元组（具体粒度由优化器决定）。
        2.  在内存中使用 `AND`/`OR` 操作对这些位图进行合并。
        3.  最后只访问那些在合并后位图中被标记为“需要读取”的数据页/元组。
    *   **效果**：这本质上也是在访问堆表（回表）之前，在索引层面完成了尽可能多的过滤，效果与 MySQL 的 ICP 类似甚至更强。在 `EXPLAIN` 中看到 **`Bitmap Index Scan`** 后跟 **`Bitmap Heap Scan`** 就体现了这一过程。

*   **Oracle：**
    *   **支持情况**：Oracle 拥有非常成熟的优化器，其 **“表访问过滤谓词”** 机制可以实现类似下推的功能。虽然没有一个专门的名称，但优化器在执行计划中会尽可能早地应用过滤条件。
    *   **确认方式**：在执行计划的 `Predicate Information` 部分，可以看到某些过滤条件是在 `TABLE ACCESS BY INDEX ROWID` 操作中应用的，这表示在通过索引拿到ROWID后、访问表之前或之中进行了过滤，也是一种下推形式。

---

## 二、索引合并

### 1. 核心概念

**索引合并** 是一种优化技术，当一条 SQL 查询的 `WHERE` 子句中包含多个条件，并且这些条件分别可以被不同的索引覆盖时，数据库会**同时扫描这些索引，然后将各自的结果进行合并（交集、并集或先并后交），最后再回表或直接返回结果**。

它的出现是为了解决“没有完美的复合索引来覆盖所有查询条件”的问题。

### 2. 合并算法与示例

假设我们在 `users` 表的 `age` 和 `city` 列上分别建立了单列索引。

```sql
CREATE INDEX idx_age ON users(age);
CREATE INDEX idx_city ON users(city);
```

执行以下查询：

```sql
SELECT * FROM users WHERE age = 25 OR city = 'Shanghai';
```

*   **没有索引合并：**
    *   优化器可能选择一个它认为最优的索引（如 `idx_age`），找到所有 `age = 25` 的记录，回表后，再由服务器层检查 `city = 'Shanghai'` 的条件。对于不满足 `age=25` 但满足 `city` 条件的记录，无法有效获取。
    *   更可能的情况是，优化器放弃使用索引，直接进行全表扫描。

*   **有索引合并：**
    1.  执行器会**同时使用 `idx_age` 和 `idx_city` 两个索引**。
    2.  从 `idx_age` 索引中找出所有 `age = 25` 的ROWID集合。
    3.  从 `idx_city` 索引中找出所有 `city = 'Shanghai'` 的ROWID集合。
    4.  对这两个ROWID集合取 **并集**。
    5.  根据合并后的ROWID集合进行回表，读取完整数据。

**常见的索引合并算法：**
*   **Intersect 合并**：对多个索引扫描结果的ROWID集合取**交集**。常用于 `AND` 条件的查询。
    *   `WHERE age = 25 AND city = 'Shanghai'`
*   **Union 合并**：对多个索引扫描结果的ROWID集合取**并集**。常用于 `OR` 条件的查询。
    *   `WHERE age = 25 OR city = 'Shanghai'`
*   **Sort-Union 合并**：是 Union 的变种。当从各个索引获取的ROWID不是有序时，先对它们排序，再取并集。

### 3. 各数据库差异

*   **MySQL：**
    *   **支持情况**：明确支持并命名为 Index Merge 优化。
    *   **确认方式**：在 `EXPLAIN` 的 `type` 列显示 **`index_merge`**，同时在 `Extra` 列会显示具体的合并方式，如 **`Using union(idx_age, idx_city)`**, **`Using intersect(...)`**, 或 **`Using sort_union(...)`**。
    *   **注意**：MySQL 的索引合并是一个“最后的手段”，优化器在认为它比全表扫描快时才会使用。可以通过 `optimizer_switch` 变量来开启或关闭 `index_merge`。

*   **PostgreSQL：**
    *   **支持情况**：同样支持，但其实现机制同样是基于强大的 **位图索引扫描**。
    *   **工作原理**：对于上面的 `OR` 查询，PostgreSQL 会：
        1.  对 `idx_age` 进行位图扫描，生成一个位图。
        2.  对 `idx_city` 进行位图扫描，生成另一个位图。
        3.  对这两个位图进行 `OR`（按位或）操作，生成最终位图。
        4.  根据最终位图访问堆表。
    *   **效果**：这本质上就是一种索引合并。在 `EXPLAIN` 中，你会看到两个 `Bitmap Index Scan` 子计划，然后是一个 `BitmapOr` 节点，最后是 `Bitmap Heap Scan`。

*   **Oracle：**
    *   **支持情况**：Oracle 也支持类似概念，可以通过 `AND-EQUAL` 操作或转换 `OR` 为 `UNION ALL` 来实现。
    *   **`AND-EQUAL`**：在较早的版本中，执行计划可能出现 `AND-EQUAL` 操作，它接收多个单列索引扫描的ROWID并取交集。但在现代版本中，优化器更倾向于推荐或直接使用复合索引。
    *   **OR 转换**：对于 `OR` 条件，Oracle 优化器可能会将查询重写为使用 `UNION ALL` 的形式，从而让每个分支都能利用一个索引。
    *   **倾向性**：Oracle 的优化器非常强大，但其文档更强调设计**合适的复合索引**是最高效的方案，索引合并通常是复合索引不可用时的备选方案。

---

## 三、核心差异总结对比

| 特性       | MySQL                                                                                                                       | PostgreSQL                                                                                                             | Oracle                                                                                  |
|:---------|:----------------------------------------------------------------------------------------------------------------------------|:-----------------------------------------------------------------------------------------------------------------------|:----------------------------------------------------------------------------------------|
| **索引下推** | **明确支持，称为ICP**。<br/>- 从 5.6 开始。<br/>- `EXPLAIN` 显示 `Using index condition`。<br/>- 主要减少回表。                                   | **通过位图扫描实现类似且更强的功能**。<br/>- 没有专门术语。<br/>- `EXPLAIN` 显示 `Bitmap Index Scan` -> `Bitmap Heap Scan`。<br/>- 在索引层面进行复杂逻辑过滤。 | **优化器自动进行谓词下推**。<br/>- 没有专门术语，是优化器基础能力。<br/>- 在执行计划细节中体现。                               |
| **索引合并** | **明确支持，称为Index Merge**。<br/>- `EXPLAIN` 显示 `index_merge` 和 `Using union/intersect`。<br/>- 提供 Intersect/Union/Sort-Union 算法。 | **通过位图扫描实现**。<br/>- 是核心功能的一部分。<br/>- `EXPLAIN` 显示多个 `Bitmap Index Scan` 和 `BitmapAnd/BitmapOr` 节点。<br/>- 非常灵活和强大。      | **支持，但实现方式多样**。<br/>- 早期有 `AND-EQUAL`。<br/>- 常通过查询重写（如OR转UNION ALL）实现。<br/>- 更推崇使用复合索引。 |

## 四、总结

1.  **设计优先于优化**：无论是索引下推还是索引合并，都是为了弥补索引设计上的不足。**最根本的优化永远是设计一个能够最大限度满足查询需求的复合索引**。
2.  **理解优化器行为**：了解你所使用的数据库对这些优化技术的支持情况和实现方式，有助于你更好地解读执行计划，并进行针对性的调优。
3.  **MySQL**：ICP 和 Index Merge 是它的重要特性，在无法创建理想复合索引时非常有用，需要会识别。
4.  **PostgreSQL**：其**位图索引扫描**机制统一并高效地处理了其他数据库中“索引下推”和“索引合并”所解决的问题，是其优化器的一大优势。
5.  **Oracle**：拥有极其成熟的优化器，它会尝试各种转换和下推。虽然支持合并，但它的最佳实践指南始终强调创建正确的索引是首选方案。