# 回忆和CAS的弊端

## 风口上也难飞的猪

突然回忆起2018年在成都找工作的一段经历。

那时刚到成都，因为没有毕业只能找一份实习工作。

实习的时候有三个人一起面试，面试官让每个人说一下自己对软件行业的看法和自己的规划。

当时我说：

“我以前觉得数据库很酷，想做数据库工程师（也就是DBA），而且在整个软件生命周期中，数据是不可或缺的，所以我觉得数据一定是未来的核心。”

当时我还没有接触过大数据相关的概念，虽然思想比较浅显，但是在今天看来也没有错。但是接下来我不知道怎么脑抽抽了，说了下面这段话：

“但是现在的数据库技术都已经很成熟了，而且有很多快速开发技术，很多企业也不需要专门的DBA，数据库的运维都由开发人员维护，我也想从事具体的研发工作。”

然后我就开心的去当CRUD boy了。

可见我真是脑子真是抽抽了，🌚我大概就算是站在风口上都不一定能飞起来。

## 继续正题——CAS的实现
诶，怎么又在将这个？因为还没讲完嘛，`CAS`在没有锁的情况下还能保证并发安全，难道没有一点弊端吗？

在 Java 中，Java 并没有直接实现 CAS，CAS 相关的实现是通过 C++ 内联汇编的形式实现的。Java 代码需通过 JNI 才能调用。

而在CPU层面，实现CAS操作的常见的指令是`CMPXCHG`。

> CMPXCHG是“Compare and Exchange”的缩写，它是一种原子指令，用于在多核/多线程环境中安全地修改共享数据。
> CMPXCHG在很多现代微处理器体系结构中都有，例如Intel x86/x64体系。对于32位操作数，这个指令通常写作CMPXCHG，而在64位操作数中，它被称为CMPXCHG8B或CMPXCHG16B。

在多核的情况下也不只是一个CMPXCHG就能实现CAS，还需要加锁。

原理就大致讲到这里，再深入下去还有的讲，但是我们得先来讲讲`CAS`的一些问题。

## CAS的弊端 {id="cas_bad"}
`CAS`有三大弊端：
1. ABA问题
2. 多个共享变量的原子操作 
3. 自旋时间


### ABA问题
ABA问题其实很好理解，在`CAS`操作过程中有三个阶段：读取->比较->替换。

在有两个线程的情况下，容易出现下图的情况：

![ABA.png](ABA.png)

线程1在读取和比较之间，其实线程2已经把变量都更新两次了，只是第二次更新为了原来的值，但是线程1并不知道这些更新操作，只要比较到相同的值，就会继续执行CAS操作。

其实这也是很好理解的，因为比较和替换是原子操作，但是比较不是，所以在这之中仍然会出现ABA问题。

ABA问题的解决也很简单，就是加版本号。增加了版本号之后，更新顺序就变为了A1->B2->A3，就能识别出不同。

从Java1.5开始JDK的atomic包里提供了一个类`AtomicStampedReference`来解决ABA问题。
这个类的`compareAndSet`方法作用是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。

但是如果增加版本号，就代表不止一个变量，还需要一个变量存储版本，这就涉及到第下一个问题了：**多个共享变量的原子操作**。

### 多个共享变量的原子操作
简单来说就是每次只能更新一个变量的值，但是在Java里好解决，通过对象进行操作，在JDK1.5提供了`AtomicReference`这个类，看名字就知道是引用类型的原子操作。

上面提到的`AtomicStampedReference`其实就是加了版本的`AtomicReference`。 
（这个类的实现等以后再深挖）

### 自旋时间
什么是自旋时间？首先`CAS`在实现层面使用了自旋的方式。

以下是关于自旋锁的定义：
> 当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。
> 这种采用循环加锁 -> 等待的机制被称为自旋锁(spinlock)。

但CAS本身不是自旋锁，只是一般的实现方案里带有重试机制，具备了自旋的性质。

而自旋时间就是进行`CAS`操作时，比较到了不同的值，于是循环进行读取-比较的步骤。在这个阶段如果一直都没有拿到原始值，CPU会一直消耗资源进行比较，进而影响到其他线程的执行。

常见的解决办法就是利用CPU的`pause`指令，可以暂停CPU的睡眠，降低读取的开销。

### 总结
总之，`CAS`是个挺好用的玩意儿，在JAVA里有很多已经实现好的类，比如`java.util.concurrent.atomic`下的类，`ConcurrentLinkedQueue`类等。