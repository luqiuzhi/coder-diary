# JVM的运行时内存区域

之前讲到了JVM的内存模型，而JVM中的内存结构也是一个重要的知识点。

以JDK1.8为例：

![code-diary.drawio.svg](code-diary.drawio.svg){ thumbnail="true" }

我们一一对以上区域进行说明：

## 程序计数器(Program Counter Register)

程序计数器主要用于字节码解释器执行时，标记当前执行的字节码所在行。

字节码解释器通过程序计数器确定当前的线程执行到了class文件的哪一行，并以此来控制程序的顺序执行、分支、循环、跳转、异常处理等执行过程。

由于Java是多线程语言，每个线程的执行进度都不一样。在多线程的章节提到每个线程的CPU时间分片结束后就会切换到其他线程执行，在多线程环境中每个线程都需要记录好自己代码执行的进度，所以`程序计数器`
是线程私有的。

程序计数器中存储的是当前字节码指令的地址，是一块很小的内存区域，也是唯一一个不会有内存溢出(`OutOfMemoryError`)的区域。

> 为什么程序计数器区域不会有内存溢出？因为这是一个可预见大小的内存区域，无论什么情况下都不会超过最大值。在JVM的文档中，有如下描述：
>
> "The Java Virtual Machine's pc register is wide enough to hold a returnAddress or a native pointer on the specific
> platform."
>
{style="note"}

程序计数器的生命周期随线程的创建而创建，随线程的消亡而消亡。

## 虚拟机栈(VM Stack)

虚拟机栈是JVM运行时中的一块核心内存区域。由栈（stack）的特性可以知道，栈中的元素是**先进后出**的。

在Java程序运行过程中了，除了本地方法外，其余的方法间调用都要通过虚拟机栈来完成。和程序计数器一样，虚拟机栈也是线程私有的。

程序每进入一个方法，就往栈中压入（栈增加元素一般成为压入）一个栈帧，每跳出一个方法(执行完毕或return)就从栈中弹出（栈删除元素一般成为弹出）一个栈帧。

虚拟机栈由 ***栈帧*** 组成，栈帧是用于支持JVM进行方法调用和执行的数据结构。每一个栈帧中都保存了局部变量表、操作栈、动态链接和返回地址。

> 在国内的博客或文档中喜欢将栈帧分为四个部分，我翻阅了其他国外的博客，一般只区分三个部分：局部变量表、操作栈和其他区域，动态链接和返回地址等信息都归位了Other。

![code-diary-虚拟机栈.drawio.svg](code-diary-虚拟机栈.drawio.svg) {thumbnail="true"}

### 局部变量表(Local Variable Table)

局部变量表其实最好理解，我们常说：局部变量是线程安全的。原因就在于局部变量是存储在局部变量表的，也就是在线程私有的虚拟机栈中，既然是线程私有的，自然也就是线程安全的了。

局部变量表中存储了当前方法定义的参数以及方法体中声明的局部变量。

局部变量表的最大容量在编译期就确定了，这是因为在局部变量表中存储是以下已知类型的数据：

- boolean
- byte
- short
- int
- long
- char
- float
- double
- reference
- ~~returnAddress~~

> 上面的`returnAddress`被删除的原因是从class编译版本号51开始，JVM的规范中就禁用了`jsr,jsr_w,ret`三个指令，所以`returnAddress`也就不常见到了。
> 
> `returnAddress`的作用我理解是保存一个字节码的地址，之所以在旧版本中需要这个类型是因为`finally`这个关键字。一个`finally`关键字可以对应多个`catch`，
> 在早期的编译器版本中为了复用`finally`生成的字节码，在不同的`catch`的字节码下面使用同一个`returnAddress`指向`finally`的字节码。类似`goto`语句的作用。
> 后面为了降低复杂度，去掉了与之相关的`jsr,jsr_w,ret`三个指令，新的实现方式简单粗暴，就是在每一个`catch`后面都生成一份`finally`的字节码。
> 
> 简单来说，returnAddress是用于方法执行过程中的异常跳转的，现在的虚拟机几乎都是用`异常表`来处理异常的问题。
>
> 可以参考R大的回答：<a href="https://www.zhihu.com/question/29056872/answer/43049999">JVM jsr和ret指令始终理解不了？returnAddress又怎么理解呢？ - RednaxelaFX的回答 - 知乎</a>
> 
> 关于这个问题在StackOverflow上还有一个小小讨论：<a href="https://stackoverflow.com/questions/57753497/what-does-at-returnaddress-mean-in-jvm">What does `at ReturnAddress` mean in JVM?</a> 

按照官方的JVM规范，对局部变量表的定义其实是`an array of variables`，也就是数组。实际实现的时候，一般

局部变量表的容量规定在JVM规范中并没有明确说明，但是JVM规范仍然给出了定义，使用`Slot`进行存储，但是`Slot`的具体大小（多少字节）由虚拟机自行决定。

### 操作数栈（Operand Stack）

操作数栈（Operand Stack）是JVM运行时数据区中的一个重要部分。每一个栈帧都包含一个后进先出（LIFO）的操作数栈，用于存储操作数和中间计算结果。操作数栈在方法执行过程中起着至关重要的作用。

在方法执行的任何时刻，操作数栈的深度是可以变化的。JVM指令集中的大多数指令都以操作数栈为目标进行操作，例如将值推入栈、从栈中弹出值、执行算术运算等。操作数栈的最大深度在编译期就已经确定，并记录在方法的字节码中。

操作数栈中的元素可以是任意的Java数据类型，包括基本类型（如int、float、long、double等）和引用类型（如对象引用）。在执行方法调用时，操作数栈还用于传递参数和接收返回值。

操作数栈的设计使得JVM指令集能够以一种简洁和高效的方式进行表达和执行。通过操作数栈，JVM能够实现跨平台的字节码解释和执行，从而保证Java程序的可移植性和一致性。

总的来说，操作数栈是JVM方法执行过程中不可或缺的一部分，它支持了方法调用、参数传递、运算操作等多种功能，为JVM的高效运行提供了基础。

操作数栈的作用：

1. 操作数存储：操作数栈用于保存方法执行期间的操作数。例如，执行加法操作时，两个加数会被推入栈顶，执行加法操作后，结果再被存入栈顶。
2. 中间结果存储：复杂表达式计算过程中，涉及的中间计算结果会临时存放在操作数栈中，方便后续指令继续使用。
3. 方法调用：在进行方法调用时，操作数栈也被用来传递参数和接受返回结果。

操作机制：

操作数栈是一个后进先出（LIFO, Last In First Out）结构，JVM指令通过 **压栈（push）和出栈（pop）** 操作来访问和操作栈顶的数据。以下是操作数栈常见的指令示例：

- 压栈指令：将数据推入栈顶。例如，`iconst_1`指令将整数1推入操作数栈。
- 出栈指令：从栈顶弹出数据。例如，`iadd`指令弹出栈顶的两个整数并将它们相加，结果再压回栈顶。
- 复制指令：复制栈顶数据。例如，`dup`指令复制栈顶元素并将副本压入栈顶。
- 交换指令：交换栈顶两个元素。例如，`swap`指令交换栈顶前两个元素的位置。

假设我们有一个简单的Java代码进行两个整数相加：

```Java
public int add(int a, int b) {
    return a + b;
}
```

上述代码在字节码中的操作如下：

1. 将`a`和`b`的值从局部变量表加载到操作数栈；
2. 执行加法操作；
3. 将结果从操作数栈保存并返回。
具体的字节码指令可能类似如下（假设`a`和`b`分别在局部变量表索引0和1处）：

```text
0: iload_0         // 将局部变量表索引0处的值加载到操作数栈
1: iload_1         // 将局部变量表索引1处的值加载到操作数栈
2: iadd            // 弹出栈顶两个整数并相加，结果压回栈顶
3: ireturn         // 将栈顶的整数返回
```

操作数栈的优点：

1. 简洁高效：使用操作数栈简化了指令集设计和硬件实现，使指令集具有较强的表达能力和解释执行的高效性。
2. 便于移植：操作数栈和指令集的设计使得JVM可以更容易地在不同平台上移植和运行。

**总结来说，操作数栈是JVM执行方法的重要机制之一，通过它的 `LIFO` 操作方式，便捷地存取操作数和中间结果，为方法执行提供了有效的计算和数据传递手段。**