# 常见数据库对四大隔离级别的设置

我们都知道SQL标准中定义了四种隔离级别：读未提交，读已提交，可重复读，串行化。

那么在不同数据库都存在四种隔离级别吗？

**简单回答是：不一样。**

数据库的四大隔离级别（Read Uncommitted, Read Committed, Repeatable Read, Serializable）是**SQL标准**中定义的。理论上，所有遵循ANSI/ISO
SQL标准的数据库都应该支持这些级别。

然而，**问题的关键在于不同数据库厂商对这些级别的具体实现方式存在显著差异**。这种差异主要体现在两个方面：

1. **如何实现**：是使用悲观锁（行锁、表锁）还是多版本并发控制（MVCC）？
2. **防止的现象**：即使在同一个隔离级别下，不同数据库能防止的“现象”（如幻读）也可能不同。

---

## 深入解析差异

### 1. 标准 vs. 实现

SQL标准定义了不同隔离级别下可能或不可能出现的几种现象：

* **脏读**：读到了另一个事务未提交的数据。
* **不可重复读**：同一事务内两次读取同一行，得到了不同的结果（因为被其他事务修改并提交了）。
* **幻读**：同一事务内两次执行相同的查询，得到了不同的结果集（因为其他事务插入或删除了符合查询条件的行并提交了）。

标准只是规定了“在某个级别下不允许出现某种现象”，但并没有规定数据库**如何**去防止这种现象。这就给了数据库厂商巨大的实现自由度。

### 2. 核心实现机制的不同：锁 vs. MVCC

这是造成差异的根本原因。

* **基于锁的机制**：早期数据库（如MySQL的InnoDB在特定操作下、SQL Server等）大量使用读锁和写锁来实现隔离。这种方式并发性能较差，容易导致锁等待和死锁。
* **基于多版本并发控制的机制**：现代数据库（如**PostgreSQL, Oracle, MySQL InnoDB的默认方式**）普遍使用MVCC。其核心思想是：*
  *为每一行数据维护多个版本**。当一个事务开始时，它只能看到在该事务开始之前就已经提交的数据版本（一个“快照”）。写操作会创建新的数据版本，而不会直接覆盖旧数据。

**MVCC的实现使得“读”操作完全不需要加锁**，极大地提高了并发读取性能，但也使得隔离级别的表现与传统基于锁的机制有所不同。

---

## 各大数据库的具体差异举例

| 隔离级别     | SQL标准要求防止的现象         | MySQL (InnoDB)                                      | PostgreSQL                        | Oracle                                    | SQL Server                   |
|:---------|:---------------------|:----------------------------------------------------|:----------------------------------|:------------------------------------------|:-----------------------------|
| **读未提交** | 脏读、不可重复读、幻读 **都不防止** | **实际上不会出现脏读** (因为使用MVCC，总是读快照)                      | 不支持此级别（会自动升级到读已提交）                | **不支持此级别**                                | 会出现所有现象                      |
| **读已提交** | 防止脏读                 | 使用MVCC快照，**防止脏读**                                   | 使用MVCC快照，**防止脏读**                 | 使用MVCC快照，**防止脏读**                         | 使用锁，**防止脏读**                 |
| **可重复读** | 防止脏读、不可重复读           | 使用MVCC快照，**防止脏读和不可重复读**，并且**通过间隙锁防止了幻读** (InnoDB特性) | 使用MVCC快照，**防止脏读和不可重复读**，但**允许幻读** | **不支持此级别**，它的 `READ` 级别相当于 `SERIALIZABLE` | 使用锁，**防止脏读和不可重复读**，但**允许幻读** |
| **串行化**  | 防止所有现象               | 使用锁，防止所有现象                                          | 使用锁和谓词锁，防止所有现象                    | 使用锁，防止所有现象                                | 使用锁，防止所有现象                   |

**从表中可以看出几个关键差异：**

1. **MySQL的“可重复读”格外强大**：由于InnoDB使用了**间隙锁**，它在“可重复读”级别就阻止了幻读，这比SQL标准的要求更高。
2. **PostgreSQL的“可重复读”遵循标准**：它只防止不可重复读，但不防止幻读。如果要防止幻读，必须使用“串行化”级别。
3. **Oracle没有“读未提交”和“可重复读”**：Oracle的默认级别是“读已提交”，它提供了一个更高级的 `SERIALIZABLE` 级别（其行为类似于快照隔离）。
4. **PostgreSQL和Oracle甚至不允许你设置“读未提交”**：如果你尝试设置，它们会静默地将其提升到“读已提交”。

---

## 总结

1. **概念统一，实现各异**：四大隔离级别的**名称和理论定义**在所有关系型数据库中是一致的，都源自SQL标准。
2. **实现机制是根源**：不同数据库通过**锁**或**MVCC**等不同技术来实现这些级别，导致它们在**性能**和**具体能防止的并发问题
   **上表现不同。
3. **必须查阅官方文档**：**绝对不能**假设一个数据库在某个隔离级别的行为会与另一个数据库完全相同。在进行应用程序开发或数据库迁移时，
   **务必查阅当前所用数据库的官方文档**，详细了解其每个隔离级别的具体行为。
4. **默认级别也不同**：例如，MySQL InnoDB的默认级别是**可重复读**，而Oracle、PostgreSQL、SQL Server的默认级别都是**读已提交**。
