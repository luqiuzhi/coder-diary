# 缓存和数据库的一致性如何保证？有哪些方案？

## 为什么会出现不一致？

不一致通常发生在**数据更新**的阶段。主要源于两个并发操作：

1. **更新数据库后，更新/删除缓存失败**：导致缓存中是旧数据，数据库是新数据。
2. **并发读写请求**：在某个时间点，读请求可能将旧数据写入缓存。

---

## 常用方案与策略

下面介绍几种常见的方案，从简单到复杂。

### 1. Cache-Aside (旁路缓存) - 最常用模式

这是最基础、最常用的模式。读/写流程是分开的。

* **读流程 (Read)**:
    1. 接收读请求。
    2. 首先检查缓存（Redis）中是否存在数据。
    3. **缓存命中 (Cache Hit)**：直接返回缓存数据。
    4. **缓存未命中 (Cache Miss)**：从数据库查询数据。
    5. 将数据库查询到的数据写入缓存（以便后续请求命中）。
    6. 返回数据。

* **写流程 (Write)**:
    1. 接收写请求。
    2. **更新数据库**。
    3. **删除缓存**（注意：是删除，不是更新）。

**为什么是删除缓存，而不是更新缓存？**
这是一个重要的设计抉择。**删除** 优于 **更新**，原因如下：

* **性能**：如果数据需要复杂的计算才能写入缓存（比如联表查询结果），每次更新都计算一次是巨大的性能浪费，特别是该数据被多次更新但很少被读取时。
* **并发问题**：在并发写时，更新缓存的顺序可能和更新数据库的顺序不一致，导致缓存中是较旧的数据。而删除是幂等的，操作简单。

**Cache-Aside 的缺点 (不一致场景分析):**
虽然常用，但它存在经典的不一致问题：

1. **问题场景**：
   1. 请求A（写）更新了数据库。
   2. 请求B（读）读取数据库（此时读到了A更新后的新值）。
   3. 请求B将新值写入缓存。
   4. 请求A**删除缓存**。
   * 结果：缓存中是B写入的新值，数据库也是新值，一致。*
   * **但是，如果步骤2和4颠倒了**：
       * 请求A更新数据库 -> 请求A**删除缓存** -> 请求B读取数据库（旧值）-> 请求B将旧值写入缓存。
   * *结果：数据库是新值，缓存是旧值，发生不一致。*
2. **发生概率**：因为数据库写操作通常比读操作慢（加锁、写日志等），所以“先删缓存再更新数据库”更容易发生上述问题。但即使步骤顺序对了，由于网络延迟，删除缓存的操作也可能晚于读请求的写缓存操作。

**解决方案：**

* **延迟双删 (Delayed Double Delete)**：在更新数据库**后**，休眠一个短暂的时间（如几百毫秒，根据业务读取耗时估算），再次删除缓存。
    * `更新数据库 -> 删除缓存 -> 休眠 -> 再次删除缓存`
    * 第二次删除是为了清除在“休眠窗口期”内可能被写入的脏数据。
    * 缺点：休眠会降低吞吐量，且延迟时间难以精确设定。

### 2. Read-Through / Write-Through (穿透读/写)

这个模式将缓存作为主要的数据源，应用程序只与缓存交互，缓存自己负责与数据库的同步。

* **Read-Through**：应用读缓存，如果缓存没有，**缓存组件**自己负责从数据库加载并写入缓存，然后返回给应用。
* **Write-Through**：应用写缓存，**缓存组件**负责同步地（Synchronously）将数据写入数据库，然后才返回成功。

**优点**：对应用层透明，逻辑简单。
**缺点**：对缓存组件要求高，通常需要支持这些功能的自研缓存或第三方库（如一些本地缓存库）。Redis本身不直接支持，需要在应用层封装一个代理层来实现。

### 3. Write-Behind (异步写)

Write-Through 的异步版本。

* 应用写缓存后立即返回成功。
* 缓存组件会异步地、批量地将数据更新到数据库。

**优点**：性能极高，写操作延迟非常低。
**缺点**：有数据丢失风险（如果缓存宕机，未持久化的数据就丢了），一致性最弱。实现非常复杂。

### 4. 基于数据库日志（如 Binlog）的最终一致性方案 - 最可靠方案

这是大型互联网公司最常用、最可靠的方案。其核心是**让缓存层作为数据库的一个“从库”**。

**工作原理：**

1. 应用程序更新数据库（MySQL）。
2. MySQL 会将自己的更新操作记录到 Binlog 中。
3. 有一个**缓存数据同步组件**（如 Canal、Debezium）来**订阅并解析 MySQL 的 Binlog**。
4. 该同步组件解析出 Binlog 中的变更数据后，**发送消息到一个消息队列（如 RocketMQ/Kafka）** 以解耦和削峰。
5. 另一个**数据消费服务**从消息队列中取出变更消息，然后**更新或删除 Redis 中对应的缓存**。

**优点：**

* **彻底解耦**：应用程序只关心写数据库，无需处理缓存。
* **高可靠性**：基于数据库的复制机制，只要数据库更新成功，缓存最终一定会被更新。
* **高性能**：异步处理，对主业务链路无性能影响。

**缺点：**

* **架构复杂**：需要引入并维护额外的组件（Canal、MQ、消费者服务）。
* **延迟**：缓存更新有一定延迟，取决于整个链路的耗时，属于最终一致性。

---

## 方案总结与选择建议

| 方案                | 优点                  | 缺点              | 适用场景                       |
|:------------------|:--------------------|:----------------|:---------------------------|
| **Cache-Aside**   | 简单、直观、常用            | 存在不一致时间窗口       | 绝大多数业务场景，对一致性要求不是极度苛刻的情况   |
| **延迟双删**          | 缓解Cache-Aside的不一致问题 | 延迟时间难设定，降低吞吐量   | 对一致性要求稍高，且能接受短暂延迟的写多读少场景   |
| **Write-Through** | 应用逻辑简单，一致性较好        | 写延迟取决于数据库，性能有瓶颈 | 写入后立即要读的场景，本地缓存常用此模式       |
| **Write-Behind**  | 写性能极高               | 实现复杂，有数据丢失风险    | 写入吞吐量极大，对数据丢失不敏感的场景（如点击计数） |
| **Binlog同步**      | **可靠性最高，彻底解耦**      | **架构复杂**        | 大型系统，对一致性要求高，且有能力维护复杂架构的场景 |

## 其他重要实践建议

1. **给缓存设置合理的过期时间 (TTL)**：这是最后的兜底方案。即使所有更新策略都失败了，缓存数据最终也会因过期而消失，然后从数据库加载新的数据。这保证了
   **最终一致性**。
2. **针对“热点key”使用互斥锁 (Mutex Lock)**：在高并发读失效（缓存击穿）时，防止大量请求同时涌入数据库。可以使用 `SETNX` 命令在
   Redis 中设置一个锁，只让一个请求去数据库加载数据，其他请求等待或重试。
3. **保证操作原子性**：尽量保证“更新数据库”和“删除缓存”这两个操作的原子性。如果做不到，也要优先保证数据库更新成功。可以通过本地事务、消息队列、TCC等模式实现。
4. **监控与报警**：监控缓存命中率、数据库负载。当命中率骤降时，能及时收到报警并处理。

## 结论

没有银弹。对于大多数中小型系统，**Cache-Aside + 设置缓存过期时间** 是完全足够的组合。如果对一致性要求更高，可以在其基础上增加
**延迟双删**。

而对于大型分布式系统，**通过订阅数据库 Binlog 来异步失效/更新缓存** 是业界公认的最佳实践，它能以相对可靠和解耦的方式保证数据的最终一致性。