# MVCC的原理

MVCC(Multi-Version Concurrency Control)，即多版本并发控制，是数据库管理系统（DBMS）中的一个并发控制策略，用于解决并发访问冲突问题。

MVCC 的主要思想是：通过创建多个版本的数据，无锁的处理同一数据的并发读写，性能较传统的锁机制更高效。

MVCC一般在数据库的读已提交，可重复读两个隔离级别生效，用来代替锁机制。

不同数据库对MVCC的实现方式不同，以下以MySQL数据库为例。 MySQL 中，MVCC 主要与 InnoDB 存储引擎关联。

---

## 1. 为什么要用 MVCC？—— 解决的问题

在没有 MVCC 的情况下，数据库通常通过严格的锁机制来保证隔离性：

* **读操作（SELECT）**：可能会被**写操作（UPDATE, DELETE）** 阻塞（`共享锁` 与 `排他锁` 互斥）。
* **写操作**：一定会被其他**写操作**阻塞。

这种机制虽然能保证数据安全，但严重影响了并发性能，尤其是在读多写少的场景下。

MVCC 的目标就是解决这个痛点：**让读操作（快照读）永不阻塞写操作，让写操作永不阻塞读操作**。它使得 `SELECT`
查询可以在不申请共享锁的情况下，读到在某个时间点已经提交的数据，极大提升了并发能力。

---

## 2. MVCC 的核心组件

MVCC 在 InnoDB 中的实现依赖于三个核心技术和隐藏字段：

### a. 隐藏字段

InnoDB 为每一行数据（每一条记录）都添加了三个系统隐藏字段：

1. **DB_TRX_ID (6字节)**：**事务ID**。表示最后一个**插入**或**更新**此行数据的事务ID。此外，删除在内部也被视为更新，会设置一个特殊的标记位。
2. **DB_ROLL_PTR (7字节)**：**回滚指针**。指向该行数据的上一个版本的地址（存储在 undo log 中的记录）。
3. **DB_ROW_ID (6字节)**：**行ID**。如果表没有定义主键，InnoDB 会自动生成一个聚簇索引基于此字段，否则该字段不存在。

> **注意**：实际上还有一个标记记录是否被删除的隐藏字段。

这三个字段是构建数据“版本链”的基础。

### b. Undo Log (回滚日志)

Undo Log 主要提供**回滚**和**MVCC**两大功能。

* 当一条记录被**更新**时，InnoDB 会先将该行的当前值（更新前的状态）拷贝到一条 undo log 中。
* 新的更新操作会在该行上直接写入新值，并将 `DB_TRX_ID` 设置为当前事务的ID，同时将 `DB_ROLL_PTR` 指向刚刚写入 undo log
  的旧版本记录。
* 这样，对同一行数据的多次更新，会通过 `DB_ROLL_PTR` 指针形成一个**版本链**，链头是最新的记录，链尾是最老的记录。Undo Log
  就是这个版本链的存储空间。

### c. Read View (读视图)

Read View 是 MVCC 的“快照”本质体现。**它决定了在某个事务执行时，它能看到哪个版本的数据**。

当一个事务执行**快照读**（即普通的 `SELECT ...` 语句，不包括 `SELECT ... FOR UPDATE` / `LOCK IN SHARE MODE` 这类**当前读**
）时，InnoDB 会为其生成一个 Read View。它主要包含以下关键信息：

* `m_ids`：生成 Read View 时，系统中**所有活跃（已启动但未提交）的事务ID列表**。
* `min_trx_id`：生成 Read View 时，系统中**最小的活跃事务ID**。
* `max_trx_id`：生成 Read View 时，系统应该分配给**下一个事务的ID**（即最大事务ID + 1）。
* `creator_trx_id`：创建该 Read View 的**事务自己的ID**（只有写事务才有，读事务默认为0）。

---

## 3. MVCC 的工作原理：版本链 + Read View 的匹配规则

MVCC 的整个过程可以概括为：**通过 Undo Log 构建版本链，通过 Read View 实现可见性判断**。

当一个事务执行快照读时，它会访问目标数据行的最新版本。然后，通过数据行上的 `DB_TRX_ID` 和当前事务的 Read View 进行**可见性判断
**。如果该版本对当前事务不可见，就顺着版本链（通过 `DB_ROLL_PTR` 找到上一个版本）重新进行判断，直到找到第一个对当前事务可见的版本为止。

**可见性判断规则如下**：
比较数据行版本中的 `DB_TRX_ID` (假设为 `trx_id`) 和当前 Read View 中的属性：

1. **如果 `trx_id` == `creator_trx_id`**：
    * 说明该版本是由当前事务自己修改的，**可见**。

2. **如果 `trx_id` < `min_trx_id`**：
    * 说明该版本是在当前 Read View 创建之前就已经提交的事务生成的，**可见**。

3. **如果 `trx_id` >= `max_trx_id`**：
    * 说明该版本是由在当前 Read View 创建之后才启动的事务生成的，**不可见**。

4. **如果 `min_trx_id` <= `trx_id` < `max_trx_id`**：
    * 需要判断 `trx_id` 是否在 `m_ids`（活跃事务列表）中：
    * **如果在**：说明生成该版本的事务在创建 Read View 时还未提交，该版本**不可见**。
    * **如果不在**：说明生成该版本的事务在创建 Read View 时已经提交，该版本**可见**。

如果某个版本对当前事务不可见，就顺着回滚指针 `DB_ROLL_PTR` 找到上一个版本，重复上述判断规则，直到找到可见的版本或到达链尾。

---

## 4. 不同隔离级别下的 MVCC

MVCC 的行为在不同隔离级别下有所不同，主要体现在 Read View 的生成时机上：

* **READ COMMITTED (提交读)**：
    * 在**每一次**执行快照读时，都会生成一个新的 Read View。
    * **效果**：每次读都能看到其他事务**最新提交**的结果。这就解决了脏读，但可能出现不可重复读（两次读取之间，数据被其他事务提交修改了）。

* **REPEATABLE READ (可重复读 - InnoDB默认级别)**：
    * 只在**第一次**执行快照读时生成一个 Read View，后续所有的快照读都**复用**这个第一次生成的 Read View。
    * **效果**：在整个事务过程中，每次读到的数据都是一致的，就像是在事务开始时拍了个快照一样。这就解决了不可重复读。并且，InnoDB
      通过 **Next-Key Lock** 机制配合 MVCC，在这个级别下也避免了幻读。

* **READ UNCOMMITTED**：直接读最新版本，根本不使用 MVCC。
* **SERIALIZABLE**：通常通过加锁来实现，不使用 MVCC 的快照读。

---

## 5. 版本清理 - Purge 机制

Undo Log 不能无限增长。当系统里没有任何一个 Read View 需要用到某条旧的undo log记录（即没有任何事务需要看到这个旧版本）时，这个旧的undo
log记录就可以被安全地清理掉了。这个清理过程由 InnoDB 的 purge 线程在后台完成。

**这也解释了长事务的一个巨大危害**：如果一个老事务一直不提交，它产生的 Read View 会一直保留，导致它可能“看见”的旧版本数据都无法被
purge 线程清理，从而使得 Undo Log 不断膨胀，最终可能导致磁盘爆满和历史数据无法回收。

## 总结

| 组件/概念         | 作用                          | 类比                                |
|:--------------|:----------------------------|:----------------------------------|
| **隐藏字段**      | 记录事务ID和回滚指针，构成数据行的版本链。      | 链表节点的 `next` 指针和作者ID。             |
| **Undo Log**  | 存储数据行的历史版本，是版本链的实际载体。       | Git 的提交历史记录。                      |
| **Read View** | 决定事务能看到哪个版本的数据，是“快照”的实现。    | 给整个版本链拍一张照片，规定只能看到某个时间点前的提交。      |
| **可见性判断**     | 通过一套规则，在版本链中寻找对当前事务可见的最新版本。 | 沿着Git历史向前找，直到找到一条由自己或已提交的作者提交的记录。 |
| **Purge 线程**  | 清理不再被任何事务需要的旧版本数据，回收空间。     | 清理无人再使用的古老备份。                     |

MVCC 通过这种“空间换时间”和“无锁读”的方式，极其巧妙地平衡了数据库的**并发性能**和**事务隔离性**，成为了现代数据库引擎的基石技术。

## 可以思考的问题

1. 上面提到的事务id是在什么时候生成的？由谁生成？如何判断当前事务为只读事务还是写事务？
2. 数据的版本链在什么时候更新？Undo Log在什么时候生成？
3. MySQL中一条数据同一时间只会有一个读视图存在吗？
4. 数据，读视图，当前事务之间的关系是什么样的？
5. 每一个读视图存在期间，多次读取到的同一条数据的版本链是固定的还是变化的？
6. 上面提到的`min_trx_id` <= `trx_id` < `max_trx_id`这种情况，什么时候会出现 `trx_id` 不在 `m_ids` 中呢？
7. 什么情况下会用到`trx_id` == `creator_trx_id`这条规则？
8. MySQL中每条数据多次更新时产生的版本链，在回滚的时候会直接删除版本链上的数据吗？回滚时会直接删除Undo Log中相应的日志吗？

如果能很好的回答上面的问题就说明对MVCC的理解已经很深入了。