# DDD实践中的代码架构

## 1. 分层架构（传统四层架构）

这是最经典、最基础的DDD架构起点，由Eric Evans在书中提出。它的核心是**分离关注点**，将领域模型置于架构的核心位置。

**层级划分：**

*   **用户界面层 / 表示层：** 负责向用户显示信息和解释用户指令。
*   **应用层：** 协调整个应用程序的活动。它不包含业务逻辑，而是将任务委托给领域层中的领域对象。
    *   **包含：** 应用服务、DTO组装、事务控制、权限校验等。
*   **领域层：** 包含业务概念、信息、规则和状态。这是系统的核心。
    *   **包含：** 实体、值对象、领域服务、领域事件、聚合、仓储接口等。
*   **基础设施层：** 为其他层提供技术支持。
    *   **包含：** 仓储接口的实现（如操作数据库）、消息队列实现、邮件发送、文件存储等。

**依赖方向：** 上层可以依赖下层，但下层绝对不能依赖上层。领域层是核心，它不依赖于任何其他层。

**优点：**
*   结构清晰，易于理解，是学习DDD的最佳起点。
*   明确了领域层的核心地位。

**缺点：**
*   基础设施层对领域层有“隐性”依赖（因为要实现领域层定义的接口），这在严格分层中是一种“背离”。
*   当系统复杂时，应用层可能变得臃肿。

---

## 2. 六边形架构（端口与适配器架构）

由Alistair Cockburn提出，是DDD实践中**最流行、最推荐**的架构。它解决了分层架构中基础设施依赖的模糊性问题。

**核心思想：** 应用程序是一个“六边形”，**核心领域逻辑位于六边形的中心**，与外部世界完全隔离。外部通过“端口”与内部交互，并通过“适配器”进行转换。

*   **端口：** 相当于一个抽象的协议或接口，由应用/领域层定义。比如仓储接口、消息发布接口。
*   **适配器：**
    *   **驱动侧适配器（主适配器）：** 比如Controller、CLI命令，它们调用应用程序的核心。
    *   **被驱动侧适配器（次适配器）：** 比如数据库访问实现（RepositoryImpl）、调用外部API的客户端，它们实现核心定义的端口。

**依赖方向：** 依赖永远指向内部。**外部适配器依赖内部的端口**。

**优点：**
*   **真正的解耦：** 领域核心完全不关心外部世界，极大地提升了可测试性（通过Mock适配器即可测试核心逻辑）。
*   **技术细节与业务逻辑彻底分离。**
*   易于替换外部依赖（如数据库、第三方服务）。

---

## 3. 清洁架构（洋葱架构）

由Robert C. Martin（Uncle Bob）提出，与六边形架构思想高度一致，但层次划分更细致。

**核心思想：** 像洋葱一样，由内到外，依赖关系指向圆心。**越靠近中心，抽象级别越高，稳定性越强。**

**层级划分（由内到外）：**

1.  **领域实体层：** 最核心，包含实体和业务规则。
2.  **领域服务层：** 包含应用无关的业务逻辑。
3.  **应用服务层：** 包含用例相关的应用逻辑（协调领域对象）。
4.  **接口适配器层：** 包含Controller、Presenter、Gateway实现等，将外部数据格式转换为内部使用的格式。
5.  **框架与驱动层：** 最外层，是具体的框架（如Spring Boot）和工具（如数据库、Web服务器）。

**依赖规则：** 内层不知道外层的任何东西。外层代码可以依赖内层定义的接口。

**优点：**
*   与六边形架构优点类似，但层次更清晰，对“用例”的强调更强。
*   框架无关性极高，核心业务逻辑可以轻松跨框架复用。

---

## 4. 面向微服务的架构

当系统被拆分为多个微服务时，DDD是进行服务拆分的绝佳指导方法。每个微服务都应该是**一个界限上下文**。

**架构选择：**
*   在**单个微服务内部**，你通常会采用上述的**六边形架构**或**清洁架构**来组织代码。
*   在**服务之间**，通过**领域事件**、**API**、**消息队列**等进行通信。

**关键点：**
*   **数据库按服务分离：** 每个微服务拥有自己独立的数据库，这强制了界限上下文之间的解耦。
*   **API网关：** 处理服务聚合、认证、路由等跨领域关注点。
*   **事件驱动：** 使用领域事件来维护服务间的数据最终一致性。

**优点：**
*   实现了技术异构、独立部署和扩展。
*   DDD的界限上下文与微服务的边界天然匹配。

---

## 5. 事件驱动架构（CQRS & 事件溯源）

这是一种更高级的架构模式，常与DDD结合，用于处理特别复杂的业务场景。

*   **CQRS（命令查询职责分离）：**
    *   **核心思想：** 将模型的**写操作（命令）** 和**读操作（查询）** 分离。
    *   **写模型：** 使用完整的DDD聚合来处理命令，保证业务一致性。
    *   **读模型：** 使用高度优化的、非规范化的数据模型（如视图库）来处理查询，追求性能。
    *   **与DDD结合：** 非常适合读写负载差异大的场景，让写模型可以专注于业务逻辑，而不被查询需求污染。

*   **事件溯源：**
    *   **核心思想：** 不存储实体的当前状态，而是存储**导致状态变化的所有事件**。当前状态是通过回放所有事件计算出来的。
    *   **与DDD结合：** 事件就是**领域事件**。它完美地记录了业务的完整历史，为审计、回溯、实现复杂业务逻辑提供了极大的便利。
    *   **通常与CQRS结合使用：** 事件存储作为写模型，通过投影生成读模型。

**优点：**
*   极高的性能和可扩展性。
*   提供了无与伦比的审计和追溯能力。
*   业务意图明确，事件本身就是业务文档。

**缺点：**
*   架构复杂，学习曲线陡峭。
*   不适合所有场景，通常只在复杂核心域中使用。

## 6. 菱形架构

菱形架构是六边形架构的直观化体现，它强调了系统内外交互的对称性和平衡性。其核心目标与六边形架构完全一致：**将核心业务逻辑与外部依赖（如UI、数据库、第三方服务）彻底分离，让核心业务成为一个可独立测试和演进的“钻石”。**

**核心思想：**
应用程序的核心（领域模型和应用服务）像一颗璀璨的“钻石”，被保护在架构的中心。任何外部方的访问都必须通过“端口”，并经由特定的“适配器”进行协议或数据的转换。这颗“钻石”不关心谁在调用它，也不关心数据最终存储在哪里，它只关心自身的业务规则。

**架构组成：**

*   **核心领域（钻石中心）：**
    *   **领域模型：** 包含实体、值对象、聚合、领域事件等。
    *   **应用服务：** 协调领域对象完成特定的用例任务，不包含业务规则。
    *   **端口（接口）：** 定义在核心领域层，是与外部世界交互的契约。
        *   **输入端口（北向）：** 通常由应用服务接口充当，定义了外部可以触发哪些用例。
        *   **输出端口（南向）：** 通常由仓储接口、外部服务客户端接口等充当，定义了核心领域需要从外部获取哪些能力。

*   **适配器（钻石边缘）：**
    *   **主适配器 / 驱动者适配器（北向）：** 它们“驱动”应用程序。例如：
        *   **Web控制器适配器：** 接收HTTP请求，调用输入端口（应用服务），并将返回结果组装成JSON等格式。
        *   **CLI命令适配器：** 解析命令行参数，调用输入端口。
        *   **测试框架适配器：** 在测试中调用输入端口。
    *   **次适配器 / 被驱动者适配器（南向）：** 它们被应用程序“驱动”。例如：
        *   **数据库仓储适配器：** 实现输出端口（仓储接口），具体负责对MySQL、MongoDB等数据库的CRUD操作。
        *   **外部API客户端适配器：** 实现输出端口，负责调用另一个微服务或第三方API。
        *   **消息发布适配器：** 实现输出端口，负责将领域事件发布到消息队列（如RabbitMQ、Kafka）。

**依赖方向：**
依赖永远指向核心。**适配器依赖于端口（接口）**，而端口（接口）由核心领域定义并实现。这意味着：
*   Web控制器（适配器）依赖于应用服务（端口）。
*   数据库实现（适配器）依赖于仓储接口（端口）。

**优点：**
*   **极高的可测试性：** 核心领域逻辑可以在完全不启动Web服务器、不连接数据库的情况下进行测试，只需使用Mock或Stub实现输出端口即可。
*   **技术细节与业务逻辑彻底解耦：** 可以轻松更换Web框架（从Spring MVC换到WebFlux）、数据库（从MySQL换到PostgreSQL）而无需修改核心业务代码。
*   **架构意图清晰：** 通过代码结构就能清晰地分辨出哪些是业务核心，哪些是技术实现细节，便于团队理解和维护。
*   **框架无关性：** 核心领域不依赖于任何外部框架，提升了代码的纯粹性和可移植性。

**缺点：**
*   **初始复杂度较高：** 相比传统的分层架构，需要定义更多的接口和组装类，对于简单项目可能显得“过度设计”。
*   **学习曲线：** 团队成员需要理解“依赖倒置”原则和端口-适配器概念，对设计能力要求更高。
*   **需要严格的团队纪律：** 必须防止业务逻辑泄漏到适配器中，或者为了图方便而在核心层直接引入外部依赖。

**适用场景：**
*   与六边形架构完全相同，是现代DDD实践中最推荐的架构模式之一。
*   适用于所有对可维护性、可测试性和架构清晰度有较高要求的项目，无论是单体应用还是微服务内部的组件。

