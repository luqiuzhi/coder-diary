# MySQL中为什么like &apos;%xx&apos; 会使索引失效（详细解答版）

## 详细解释：从B+树数据结构出发

### 1. 联合索引在B+树中是如何组织的？

想象一下联合索引 `(A, B)` 在B+树中的结构：

* **排序规则**：B+树首先按照字段 `A` 的值进行**全局排序**。在 `A` 的值相同的情况下，再按照字段 `B` 的值进行排序。
* **类似电话簿**：你可以把它理解为一本电话簿，先按**姓氏（A）** 排序，同姓氏的人再按**名字（B）** 排序。

| 索引条目 (A, B)      | ... |
|:-----------------|:----|
| (`Aaron`, 10)    | ... |
| (`Barry`, 15)    | ... |
| (`Barry`, 20)    | ... |
| (`Catherine`, 5) | ... |
| (`David`, 25)    | ... |

在这个结构中，如果你想查找 `A = 'Barry'` 的人，你可以利用排序快速定位到 `'Barry'` 的区域。如果你想查找
`A = 'Barry' and B = 20`，你可以先定位到 `'Barry'`，然后在 `'Barry'` 内部利用 `B` 的排序快速找到 `20`。这就是**最左前缀匹配原则
**。

### 2. 分析 `A like '%xx'` 条件

`like '%xx'` 表示：**以 `'xx'` 结尾**的任意字符串。

* **它破坏了索引的有序性**：B+树索引的快速查找（二分查找）依赖于**前缀已知**。例如，`A = 'Barry'` 或 `A like 'Bar%'`，我们知道要从字母
  `'B'` 开始查找。
* **`like '%xx'` 无法定位**：由于通配符 `%` 在开头，我们完全不知道 `A` 字段的值是以什么开头的。可能是 `'Alex'`, `'Barry'`,
  `'Catherine'`，只要它们以 `'xx'` 结尾。
* **必须遍历所有叶节点**：要找到所有以 `'xx'` 结尾的 `A`，你**没有其他选择，只能从B+树的第一条索引记录开始，顺序扫描每一条记录
  **，检查它的 `A` 字段是否以 `'xx'` 结尾。这本质上就是一次**全索引扫描**。

**结论：对于 `A like '%xx'` 这个条件，联合索引 `(A, B)` 的有序性优势完全丧失。**

### 3. 当 `A like '%xx'` 和 `B = xx` 结合时

现在我们把 `B = xx` 加进来。逻辑上，我们需要找到所有满足 `A like '%xx'` **并且** `B = xx` 的记录。

* **`B` 的有序性是局部的**：虽然在 `A` 相同的情况下，`B` 是有序的，但 `B` 在整个索引中**并不是全局有序**的。例如，`B=10`
  可能出现在 `A='Aaron'` 下，也可能出现在 `A='Zoe'` 下，它们在物理存储上是分散的。
* **查询过程**：如果数据库**强行**使用这个联合索引，过程会是这样的：
    1. **全索引扫描**：从 `(A, B)` 索引的第一个叶节点开始，逐条遍历。
    2. **检查条件**：对于每一条索引记录 `(a, b)`：
        * 检查 `a` 是否以 `'xx'` 结尾。
        * 检查 `b` 是否等于 `xx`。
    3. 如果两个条件都满足，则拿对应的主键回表查询完整数据。

**为什么优化器通常放弃使用索引？**

1. **成本太高**：上述过程需要对整个联合索引进行**全索引扫描**。如果表有100万行，索引也需要扫描100万次。
2. **回表是随机的**：即使找到了少数满足条件的索引条目，由于 `A like '%xx'` 找到的记录在磁盘上是随机分布的，回表操作会产生大量的随机I/O。
3. **不如全表扫描**：在很多情况下，优化器会计算成本后发现，直接顺序扫描整个表（全表扫描）的成本可能比 **"全索引扫描 +
   大量随机回表"** 的成本更低。全表扫描是连续的磁盘I/O，对于大数据量的顺序读取非常高效。

---

## MySQL中的特殊情况：索引下推

从 **MySQL 5.6** 开始，引入了**索引下推** 优化。这**不会改变** `A like '%xx'` 无法使用索引有序性的事实，但它能**改善**
上述过程的第2步。

* **没有索引下推**：
    1. 存储引擎遍历索引，根据 `A like '%xx'` 条件（虽然还是全扫描，但至少是在索引里扫）找到一批可能的主键。
    2. 服务层再根据 `B = xx` 条件进行过滤。

* **有索引下推**：
    1. 存储引擎遍历索引，**同时检查 `A like '%xx'` 和 `B = xx`** 两个条件。
    2. 只将同时满足两个条件的主键返回给服务层。

**索引下推的作用**：

* **减少了回表次数**：在索引层面就过滤掉了 `A like '%xx'` 但 `B != xx` 的记录。
* **但无法改变全索引扫描的本质**：它仍然需要扫描整个索引树，只是减少了一些回表操作。如果匹配的记录非常少，索引下推能带来一些性能提升。但如果
  `A like '%xx'` 匹配的记录很多，全索引扫描的成本依然很高，优化器可能还是会选择全表扫描。

在 `EXPLAIN` 中，如果你看到 `type = index` 并且 `Extra = Using where; Using index`，就表示它在进行全索引扫描并使用索引下推。

## 总结

| 操作                            | 对索引的影响          | 解释                                                           |
|:------------------------------|:----------------|:-------------------------------------------------------------|
| **`A like '%xx'`**            | **破坏索引有序性**     | 通配符在前缀，无法利用B+树的有序结构进行快速定位，**必须全索引扫描**。                       |
| **`B = xx`**                  | **在局部有序，但全局无效** | 由于最左前缀 `A` 失效，`B` 的全局有序性也不存在，无法单独用于快速查找。                     |
| **`A like '%xx' and B = xx`** | **联合索引基本失效**    | 优化器倾向于选择**全表扫描**，因为"全索引扫描+随机回表"的成本可能更高。即使使用索引（全索引扫描），其效率也极低。 |

**最佳实践**：
如果 `B` 的选择性非常高（即 `B=xx` 只有很少的记录），可以尝试创建一个单独的索引 on `(B)`。这样查询可能会走这个单列索引，先快速找到所有
`B=xx` 的记录，然后再在服务层过滤 `A like '%xx'`。但这需要根据实际数据分布来判断。最根本的解决方案是避免在WHERE条件中使用前导通配符的
`LIKE` 查询。

## 拓展知识

![MySQL 页的结构.png](MySQL 页的结构.png)